---
title: "Prova d'avaluació continuada 2"
subtitle: "Anàlisi de dades òmiques"
author: "Núria Mercadé Besora"
institute: "Universitat Oberta de Catalunya"
date: last-modified
date-format: "DD-MM-YYYY"
format:
  pdf:
    toc: true
    toc-title: Taula de continguts
    toc-depth: 2
    documentclass: article
    keep-tex: true
    number-sections: false
    indent: false
    geometry:
      - top=30mm
      - left=30mm
      - right=30mm
      - bottom=30mm
    fig-pos: "H"
template-partials:
- before-body.tex
- toc.tex
crossref:
  fig-title: Figura     # (default is "Figure")
  tbl-title: Taula     # (default is "Table")
  fig-prefix: Figura   # (default is "Figure")
  tbl-prefix: Taula    # (default is "Table")
code-block-bg: "#f4f4f6"
code-block-border-left: "#4c5c68"
warning: false
highlight-style: github
bibliography: references.bib
---


```{r}
#| echo: false
#| output: false
library(Biobase)
library(GEOquery)
library(dplyr)
library(tidyr)
library(hgu133plus2.db)
library(ggplot2)
library(limma)
library(pheatmap)
library(clusterProfiler)
library(enrichplot)
library(genefilter)
library(latex2exp)

# knitr::opts_chunk$set(fig.pos = "H", out.extra = "")
```

# Introducció i objectius
La dermatitis per contacte al·lèrgic (DCA) es caracteritza per una inflamació local a la pell. Al·lèrgens comuns inclouen metalls, perfums, colorants i preservatius. Quan una persona al·lèrgica està exposada a l'al·lergen, les quimioquines recluten limfòcits T específics a la pell, on les cèl·lules experimenten una proliferació extensa (@Rustemeyer2020). Les cèl·lules T activades produeixen i alliberen posteriorment alts nivells de citocines, i així va provocar un procés inflamatori que condueix a l'èczema.

@Pedersen2007 van dur a terme el primer estudi dels canvis en l'expressió genètica des de l'exposició a l'al·lergen fins a l'aparició de l'èczema en DCA. Van dur a terme un estudi de microarrays d'ADN on van participar 12 dones (5 al·lèrgiques al níquel i 5 no al·lèrgiques). Es va exposar la pell que cobreix les natges superiors a pegats amb un contingut de sulfat de níquel del 5%. Tots els participants van ser exposats a 3 pegats amb temps d'exposició diferents: 7, 48 i 96 hores. Es va realitzar una biòpsia cutània per a l'anàlisis de microarrays abans de l'exposició, i just en acabar l'exposició a cada un dels pegats de níquel. Tots els al·lèrgics al níquel van reaccionar amb èczema a les 48 i 96h, en canvi, no es va desenvolupar èczema després de les 7h d'exposició. En el grup control (no al·lèrgics) no es va veure èczema en cap moment.

De les 48 biòpsies, 34 van resultar en RNA de suficient qualitat i quantitat per procedir amb l'anàlisi de microarrays. Les dades resultants s'han dipositat al repositori públic Gene Expresion Omnibus (GEO) amb l'identificador "GSE6281".

L'objectiu d'aquest treball, és utilitzar les dades de seqüenciació d'aquest estudi per respondre les preguntes següents:

1) Hi ha diferències en l'expressió de gens entre pacients de DCA i el grup control abans de l'exposició?
2) Hi ha diferències en l'expressió de gens entre pacients de DCA i el grup control a les 7h d'exposició, tot i no haver-hi diferències visibles (no hi ha èczema encara)?
3) Quines diferències en l'expressió genètica es produeixen entre al·lèrgics i no al·lèrgics al cap de 48 hores d'exposició, un cop l'èczema ja és visible? Hi ha les 96h d'exposició?

# Material i mètodes
L'anàlisi de dades es durà a termen en R, versió 4.2.2, fent ús de paquets d'anàlisis de dades bioinformàtiques del repositori de [Bioconductor](https://www.bioconductor.org/).

## Font de dades
Aquest estudi conté 34 mostres, 18 pertanyen al grup d'al·lèrgics al níquel (AN) i 16 al grup control (C). 7 de les mostres són a temps 0h (abans de l'exposició), 7 més són a les 48h, i a les 7h i 96h disposem de 10 mostres per cada temps d'exposició. L'identificador serie d'aquest conjunt de dades en el portal GEO és GSE6281, i el del conjunt de dades és GDS2935. En el portal [GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi)  del dataset a part d'informació sobre com s'han recollit les mostres, també trobem informació sobre la seqüenciació: s'ha utilitzat la plataforma Affymetrix Human Genome U133 Plus 2.0 Array (HG-U133_Plus_2).

## Lectura i preprocessat de dades
Accedirem a les dades publicades a GEO fent ús del paquet [\texttt{GEOquery}](ttp://bioconductor.org/packages/release/bioc/html/GEOquery.html) de Bioconductor. Aquest paquet permet de manera senzilla descarregar-se dades de GEO i convertir-les en objectes de classe expressionSets, típics per l'anàlisi de dades de seqüenciació. Per fer-ho, necessitem l'identificador del dataset o be de la serie. A continuació és mostra com s'ha accedit a les dades d'estudi i s'han convertit a expressionSet fent servir funcions de \texttt{GEOquery}.

```{r, output = FALSE}
gds <- getGEO("GDS2935")
eset <- GDS2eSet(gds, do.log2 = FALSE)
```
 
### Anotació
Bioconductor conté una gran [llista](https://bioconductor.org/packages/3.18/data/annotation/) de paquets d'anotacions que permeten convertir els identificadors que utilitza cada plataforma de microarray a una anotació estándard. En el nostre cas, sabem que les dades s'han obtingut fent ús de microarrays Affymetrix Human Genome U133 Plus 2.0 Array (HG-U133_Plus_2).  Busquem a la llista quin paquet conté les anotacions per aquesta plataforma, i trobquem que és [\texttt{hgu133plus2.db}](https://bioconductor.org/packages/3.18/data/annotation/html/hgu133plus2.db.html). Afegim aquesta infromació al expressionSet de la següent manera:

```{r, output = FALSE}
annotation(eset) <-"hgu133plus2.db"
```

### Filtratge
Tot seguit utilitzarem el paquet de Bioconductor [\texttt{genefilter}](https://bioconductor.org/packages/release/bioc/html/genefilter.html) per tal d'eliminar categories amb poca variació o amb un senyal baixa de manera consistent en les mostres, ja que eliminar-les millorarà l'anàlisi de les dades @Bourgon2010. A més, també exclourem de les dades aquelles que no estiguin anotades. Les comandes per obtenir l'expressionSet filtrat són les següents:

```{r}
filter_result <- nsFilter(eset)
eset_filtered <- filter_result$eset

# Create variables with the slots pData and exprs
pData <- pData(phenoData(eset_filtered)) 
exprs <- exprs(eset_filtered)

# Visualize
pData %>% glimpse()
head(exprs)
```

### Exploració de les dades
Utilitzarem gràfics de diagrames de caixes i l'anàlisis de components principals per comprovar la normalització de les dades, o si bé és necessària alguna transformació.

## Selecció de gens diferencialment expressats
Volem comparar les mostres del grup AN amb el C en quatre situacions diferents: abans de ser exposats a níquel (temps 0h), a les 7h d'exposició (temps 7), a les 48h (temps 48) i a les 96h (temps 96).
Per fer-ho, utilitzarem models lineals generals i corregirem la variància resultant amb models bayesians empírics per a l'anàlisi de microarrays, tal com descriu @Smyth2004.

### Matrius de diseny i contrast
La matriu de diseny descriu com es distribueixen les mostres segons condicions i/o grups experimentals. Definir aquesta matriu és el primer pas per ajustar models lineals. 
Cada fila representa una mostra, i les columnes de la matriu dependran de les comparacions que es volen fer. En el nostre cas ens interessa tenir 8 columnes diferenciades corresponents als grups AN i C, en els diferents temps d'exposició: AN_0, C_0, AN_7, C_7, AN_48, C_48, AN_96, i C_96. Els valors de la matriu de disseny seràn 1 si la mostra pertany al grup i condicions indicats a la columna, o 0 si no és així. El codi per crear la matriu és el següent:

```{r}
# informative name:
time <- gsub(" ", "", pData$time)
time <- gsub("control", "0h", time)

disease <- gsub("nickel allergy", "AN", pData$disease.state)
disease <- gsub("non-allergic control", "C", disease)

group <- paste(disease, time, sep="_" )

# design matrix
design  <-  model.matrix(~ 0 + group) 
colnames(design) <- gsub("group", "", colnames(design))
rownames(design) <- pData$sample

design
```

Per altra banda, la matriu de contrastos es basa en la matriu de disseny per definir les comparacions que es volen dur a terme. Cada columna d'aquesta matriu és una comparació, i les files són els grups i/o condicions experimentals. El valors, seràn positius i negatius entre les files que representen que es volen comparar, amb la condició que la seva sigui 0. Així doncs, per a les nostres comparacions, per exemple la primera (AN vs. C a temps 0h) la fila AN_0 tindrà valor 1 en la columna corresponent a aquesta comparació, mentre que la fila C_0 tindrà valor -1. La resta de files tindran valor 0 en aquesta columna ja que no intervenen en la comparació. La matriu de contrastos la construim amb el paquet [\texttt(limma)](https://bioconductor.org/packages/release/bioc/html/limma.html) de Biocondcutor, tal com es mostra a continuació:

```{r}
cont.matrix <- makeContrasts (
  time0  = AN_0h - C_0h,
  time7  = AN_7h - C_7h,
  time48 = AN_48h - C_48h,
  time96 = AN_96h - C_96h,
  levels = design
)

cont.matrix
```

### Estimació del model i selecció de gens
Per tal d'estimar el model lineal general que utilitza models de Bayes empírics farem ús de funcions del paquet \texttt{limma}. D'aquest anàlisis obtenim estimadors estadístics com el t-moderat i els p-valors ajustats. 

Per seleccionar els gens que mostren significació estadística corregirem els p-valors utilitzant el mètode de Benjamini & Hochberg (BH) que permet controlar el nombre de falsos positius quan es duen a terme múltiples comparacions. Seleccionem els gens estadísticament significatius, utilitzant un nivell de significació del 5%. A més, utilitzem el paquet d'anotacions per saber de quins gens es tracta.

```{r, output = FALSE}
# Estmació del model ----
fit <- lmFit(eset_filtered, design)
fit.cont <- contrasts.fit(fit, cont.matrix)
fit.cont <- eBayes(fit.cont)

# Selecció de gens ----
# anotacions
anotations <- AnnotationDbi::select(hgu133plus2.db,
                                    keys = rownames(exprs),
                                    columns = c("ENTREZID", "SYMBOL"))

# functió per anotar les taules
anotateTable <- function(x) {
  x %>% 
    as_tibble() %>% 
    dplyr::rename("PROBEID" = "ID") %>%
    dplyr::inner_join(anotations, by = "PROBEID") %>%
    arrange(adj.P.Val)
}

# Top tables anotades per cada comparació
topTab_time0  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time0") %>% 
  anotateTable()
topTab_time7  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time7") %>% 
  anotateTable()
topTab_time48 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time48") %>% 
  anotateTable()
topTab_time96 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time96") %>% 
  anotateTable()

# Selecció gens estadísticament singificiatius per cada comparació
summary.fit <- decideTests(fit.cont, p.value = 0.05)
```

Aquests resultats es reportaran en forma de gràfics com el diagrama de Vann i volcanoplots, a més d'un mapa de color per visualitzar el perfil d'expressió i detectar diferents patrons.

## Anàlisis de significació biological
Un cop s'han identificat quins son els gens diferencialment expressats, comencem l'anàlisi de significació biologica per tal d'interpretar els resultats. Durem a terme dos tipus d'analisis, el d'enriquiment (o anàlisi de sobre representació), i l'anàlisi *Gene Set Expresion Analysis* (GSEA).

### Anàlisis d'enriquiment
Aquesta anàlisi ens permetrà identificar quins processos biològics estan sobrerepresentats en el nostre llistat de gens que han mostrat significació estadística en l'anàlisi de gens diferencialment expressats. Durem a terme aquesta anàlisi basant-nos en anotacions ontològiques dels gens. Per tenir en compte els múltiples testos utilitzarem BH per ajustar els p-valors. En l'anàlisi a part de diferenciar per comparacions, també diferenciarem si els gens estan sobre-expressats o bé regulats, fixant un canvi mínim en el nivell d'expressió de 0.5 en escala logarítmica en base 2. 
A continuació es mostra un exemple del codi fet servir per dur a terme aquesta anàlisi en els gens sobre expressats a temps 0.

```{r}
selectedEntrezs <- rownames(subset(topTab_time0, (logFC > 0.5) & (adj.P.Val < 0.05)))
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time0),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)
```

### Gene Set Expresion Analysis
El GSEA es basa en el canvi en l'expressió dels gens entre dos grups i/o condicions experimentals. L'anàlisi utilitza el llistat de tots els gens que s'estan estudiant, independentment de si han resultat mostrar diferències en la seva expressió en anàlisis anteriors. Els gens es classifiquen tenint en compte les seves funcions biològiques. Hi ha diferents classificacions, per l'anàlisi nosaltres farem servir base de dades *Kyoto Encyclopedia of Genes and Genomes* (KEGG). En el GSEA s'assignarà puntuacions d'enriquiment als diferents conjunt de gens segons si s'observa una coordinació en la seva sobre-expressió o regulació. S'utilitzen tests de permutació per determinar la significació estadística i s'ajusten els p-valors utilitzant BH per tenir en compte les múltiples comparacions. A continuació es mostra com a exemple el codi utilitzat per fer aquest anàlisis en la comparació a temps 0:

```{r, output = FALSE}
# sort by absolute logFC to remove duplicates with smallest absolute logFC
geneList <- topTab_time0[order(abs(topTab_time0$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  

# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

# GSEA
set.seed(123)
gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, 
                           keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]
```


# Resultats 
## Preprocessat de dades
El conjunt de dades consta de 34 mostres i 54675 gens, els quals es redueixen a 10412 desprès del filtratge.
El següent gràfic mostra els boxplots de la distribució de l'expressió per cada mostra. 

```{r, echo = FALSE}
# prepare data
data_to_plot <- exprs %>%
  as_tibble() %>%
  pivot_longer(cols = colnames(exprs), names_to = "sample") %>%
  inner_join(pData %>% 
               as_tibble() %>% 
               dplyr::select(sample, time, disease.state, agent, individual)) %>%
  mutate(value_log = log(value))

## Boxplot ----
ggplot(data_to_plot,
       aes(x = sample, y = value, color = disease.state)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Expression values")
```

Com s'observa els valors no estan normalitzats. Apliquem una transformació logarítmica de base 2 a les dades i representem de nou el gràfic anterior. Com s'observa en el gràfic següent les dades ara es mostren més normalitzades que en el cas anterior.
```{r, echo = FALSE}
eset <- GDS2eSet(gds, do.log2=TRUE)
annotation(eset) <-"hgu133plus2.db"
filter_result <- nsFilter(eset)
eset_filtered <- filter_result$eset
pData <- pData(phenoData(eset_filtered)) 
exprs <- exprs(eset_filtered)
data_to_plot <- exprs %>%
  as_tibble() %>%
  pivot_longer(cols = colnames(exprs), names_to = "sample") %>%
  inner_join(pData %>% 
               as_tibble() %>% 
               dplyr::select(sample, time, disease.state, agent, individual)) %>%
  mutate(value_log = log(value))

ggplot(data_to_plot,
       aes(x = sample, y = value, color = disease.state)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Expression values")
```

El següent gràfic mostra els dues components principals del conjunt de dades, en el qual s'observa una separació entre els grups AN i C.
```{r, echo = FALSE}
pcs <- prcomp(t(exprs), scale = FALSE) # Log data

# nice axisa labels
loads <- round(pcs$sdev^2/sum(pcs$sdev^2)*100, 1)
xlab <- c(paste("PC1", "(", loads[1],"%)"))
ylab <- c(paste("PC2", "(", loads[2],"%)"))

# plot
pcs$x %>% as_tibble(rownames = "sample") %>%
  inner_join( data_to_plot %>% distinct(sample, disease.state)) %>%
  ggplot(aes(x = PC1, y = PC2, col = disease.state)) +
  geom_point(size = 2) +
  ylab(ylab) +
  xlab(xlab) +
  geom_text(aes(y = PC2-0.3, label = substr(sample, 7, 9)), size = 3) +
  ggtitle("Principal components")
```

En representar un diagrama de grups jeràrquic, observem una separació diferenciada entre les mostres del grup AN a les 96h d'exposició i la resta. Però també, veiem dos grups diferents en la resta que separa les control dels al·lèrgics al níquel.
```{r, echo = FALSE}
time <- gsub(" ", "", pData$time)
time <- gsub("control", "0h", time)

disease <- gsub("nickel allergy", "AN", pData$disease.state)
disease <- gsub("non-allergic control", "C", disease)

inf_name <- paste(substr(rownames(pData), 7, 9), disease, time, sep="_" )

den_data <- exprs
colnames(den_data) <- inf_name
clust.euclid.average <- hclust(dist(t(den_data)), method = "average")
plot(clust.euclid.average, hang = -1)
```
## Gens diferencialment expressats
La següent imatge mostra un gràfic tipus volcanoplot per a cada una de les comparacions, on podem observar en blau els gens diferencialment expressats que s'han trobat en l'anàlisi, amb les anotacions SYMBOL.

```{r, echo = FALSE}
## Fit the linear model ----
fit <- lmFit(eset_filtered, design)
fit.cont <- contrasts.fit(fit, cont.matrix)
fit.cont <- eBayes(fit.cont)

## Anotation ----
# get gene anotation
anotations <- AnnotationDbi::select(hgu133plus2.db,
                                    keys = rownames(exprs),
                                    columns = c("ENTREZID", "SYMBOL"))

# function to add annotations to result tables
anotateTable <- function(x) {
  x %>% 
    as_tibble() %>% 
    dplyr::rename("PROBEID" = "ID") %>%
    dplyr::inner_join(anotations, by = "PROBEID") %>%
    arrange(adj.P.Val)
}

## Get top tables anotated ----
topTab_time0  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time0") %>% 
  anotateTable()
topTab_time7  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time7") %>% 
  anotateTable()
topTab_time48 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time48") %>% 
  anotateTable()
topTab_time96 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time96") %>% 
  anotateTable()

volcanoplot(fit.cont, coef = "time0", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[AN vs. C] Time 0h")

# TIME 7
volcanoplot(fit.cont, coef = "time7", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[AN vs. C] Time 7h")

# TIME 48
volcanoplot(fit.cont, coef = "time48", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[AN vs. C] Time 48h")

# TIME 96
volcanoplot(fit.cont, coef = "time96", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[AN vs. C] Time 96h")
```

A conitnuació es mostra el diagrama de Vann on podem veure elnombre de gens regulats "up" i "down" per cada comparació, i quins són comuns entre comparacions. Observem com a temps 7 no trobem cap diferència, mentre que a temps 0 n'observem per dos gens. En canvi, a temps 48h i 96h, coincidint amb l'aparició d'èczema en AN, veien un nombre major de gens diferencialment expressats.

```{r, echo = FALSE}
summary.fit <- decideTests(fit.cont, p.value = 0.05, lfc = 0.5)
vc <- vennCounts(summary.fit)
vennDiagram(vc, 
            include=c("up", "down"),
            counts.col=c("red", "blue"),
            circle.col = c("red", "blue", "green3", "gold"), 
            cex=c(1, 1, 1, 1))
```
Finalment, fem la representació dels pefils d'expressió utilitzant un mapa de colors. Els resultats també suggereixen un canvi en l'expressió de gens en AN a partir de les 48 hores d'exposició. 
```{r, echo = FALSE}
topGenes0 <- subset(topTab_time0, (abs(logFC)> 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes7 <- subset(topTab_time7, (abs(logFC)> 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes48 <- subset(topTab_time48, (abs(logFC)> 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes96 <- subset(topTab_time96, (abs(logFC)> 0.5) & (adj.P.Val < 0.05))$SYMBOL

topGenes <- unique(c(topGenes0, topGenes7, topGenes48, topGenes96))

exprs_symb <- exprs
rownames(exprs_symb) <- anotations$SYMBOL

mat  <- exprs_symb[topGenes, ]
mat  <- mat - rowMeans(mat)
colnames(mat) <- group
pheatmap(mat)
```

## Signifiació bioloògica
Degut als resultats de les comparacions prèvies, on s'ha vist que només hi ha un diferència entre l'expressió de gens a les 48 i 96h, els anàlisis de signifiació biològica només es duran a terme per aquestes dues comparacions.

### Anàlisis d’enriquiment
[Comparació AN vs. C a les 48h d'exposició]{.underline}

A continuació es mostren els resultats de l'anàlisi d'enriquiment a les 48h per els gens sobre expressats. Els resultats es represent amb un gràfic de punts, una visualització jeràrquica de les ontologies genètiques significatives, gene network, i un mapa d'enriquiment.
```{r, echo = FALSE}
selectedEntrezs <- subset(topTab_time48, (logFC > 0.5) & (adj.P.Val < 0.05))$ENTREZID
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time48),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 48h; up-regulated"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# herarchical visualization of GO terms
goplot(ego, showCategory = 5, cex = 0.5)  + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)

# Enrichment map
ego_sim <- pairwise_termsim(ego)
emapplot(ego_sim, cex_label_category=0.5) + ggtitle(title)
```

Per els gens que s'han regulat no s'han trobat termes enriquits.




[Comparació AN vs. C a les 96h d'exposició]{.underline}

A continuació mostrem els resultats per els gens sobre-expressats.
```{r, echo = FALSE}
selectedEntrezs <- subset(topTab_time96, (logFC > 0.5) & (adj.P.Val < 0.05))$ENTREZID
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time96),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 96h; up-regulated"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# herarchical visualization of GO terms
goplot(ego, showCategory = 5, cex = 0.5)  + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)

# Enrichment map
ego_sim <- pairwise_termsim(ego)
emapplot(ego_sim, cex_label_category=0.5) + ggtitle(title)
```
Igual que en les 48h, els resultats de l'ànalisi per els gens regulats, resulta en que no hi ha termes significativament enriquits.

### Gene Set Expresion Analysis
Els reultats del anàlisi GSEA abans de l'exposició no són significatius, i a temps 7h obtenim el següent:
```{r, echo=FALSE}
geneList <- topTab_time7[order(abs(topTab_time7$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]
```


El nombre de *pathways* biologics significatius augmenta considerablement a les 48h:
```{r, echo=FALSE}
geneList <- topTab_time48[order(abs(topTab_time48$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]
```

A continuació es mostra el resultat de GSEA a les 96h, que és molt similar al de les 48h.
```{r, echo=FALSE}
geneList <- topTab_time96[order(abs(topTab_time96$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]
```

# Discusió 
Els resultats presentats en aquest document estan molt en línia amb els van publicar @Pedersen2007. A les 7h no s'observa diferencies significatives entre els dos grups, en canvi, a les 48h i 96h, quan ja es mostra l'èczema, si que en veiem. A més, de l'anàlisi de significació biològica els resultats a temps 48h i 96h mostren resultats molt plausibles amb el coneixement que és té dels processos biologics que es desenvolupen quan s'entra en contacte amb un al·lergen (e.g. leukocyte migration involved in inflammatory response, regulation of defense response, chemokine signaling pathway...).

Aquests estudi té algunes limitacions. Per començar, ens trobem amb les limitacions habituals en estudis de microarrays que inclouen l'efecte batch. A més, la mida de la mostra és molt petita (12 persones, 34 mostres en 4 cursos temporals per dos grups de població). Aquesta limitació pot portar a tenir un nombre major de falsos positius i falsos negatius, a més de limitar la reproductibilitat de l'estudi. Un altra limitació és que les mostres corresponen a dones de mitjana edat, el que en limita la generalització dels resultats a la població general. 
Punts forts de l'estudi és que els resultats obtinguts estan en línia amb evidencies anteriors @... . A més l'estudi utilitza paquets de Bioconductor per a l'anàlisi de dades, els quals han estat validats anteriorment i són àmpliament utilitzats en el camp de la bioinformàtica.

Aquest treball és un primer pas per al descobriment dels gens que intervenen en el desenvolupament d'èczema per DCA. Cal seguir investigant sobre les bases d'aquest estudi per donar com a definitius els resultats obtinguts, i proporcionar més evidencies científiques sobre els processos biològiques que tenen lloc en DCA.



# Codi
```{r, eval=FALSE}
## Packages ----
library(Biobase)
library(GEOquery)
library(dplyr)
library(tidyr)
library(hgu133plus2.db)
library(ggplot2)
library(limma)
library(pheatmap)
library(clusterProfiler)
library(enrichplot)
library(genefilter)

# Use GEOquery to download the dataset with dataset accesion ID GDS2935
gds <- getGEO("GDS2935")
eset <- GDS2eSet(gds, do.log2=FALSE)

# Annotation
annotation(eset) <-"hgu133plus2.db"

# filter genes with little variation or low signal across samples, and those 
# with inssuficient annotations
filter_result <- nsFilter(eset)
eset_filtered <- filter_result$eset


# Create variables with the slots pData and exprs
pData <- pData(phenoData(eset_filtered)) 
exprs <- exprs(eset_filtered)

# EXPLORATORY DATA ANALYSIS ----
# prepare data
data_to_plot <- exprs %>%
  as_tibble() %>%
  pivot_longer(cols = colnames(exprs), names_to = "sample") %>%
  inner_join(pData %>% 
               as_tibble() %>% 
               dplyr::select(sample, time, disease.state, agent, individual)) %>%
  mutate(value_log = log(value))

## Boxplot ----
ggplot(data_to_plot,
       aes(x = sample, y = value, color = disease.state)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Expression values")

## Boxplot - log
ggplot(data_to_plot,
       aes(x = sample, y = value_log, color = disease.state)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Log expression values")

# Logarithmic transform data shows better results regarding normalisation,
# therefore we work with log2 data:
eset <- GDS2eSet(gds, do.log2=TRUE)
annotation(eset) <-"hgu133plus2.db"
filter_result <- nsFilter(eset)
eset_filtered <- filter_result$eset
pData <- pData(phenoData(eset_filtered)) 
exprs <- exprs(eset_filtered)
data_to_plot <- exprs %>%
  as_tibble() %>%
  pivot_longer(cols = colnames(exprs), names_to = "sample") %>%
  inner_join(pData %>% 
               as_tibble() %>% 
               dplyr::select(sample, time, disease.state, agent, individual)) %>%
  mutate(value_log = log(value))


## PCA ----
# pca with log data
pcs <- prcomp(t(exprs), scale = FALSE) # Log data

# nice axisa labels
loads <- round(pcs$sdev^2/sum(pcs$sdev^2)*100, 1)
xlab <- c(paste("PC1", "(", loads[1],"%)"))
ylab <- c(paste("PC2", "(", loads[2],"%)"))

# plot
pcs$x %>% as_tibble(rownames = "sample") %>%
  inner_join( data_to_plot %>% distinct(sample, disease.state)) %>%
  ggplot(aes(x = PC1, y = PC2, col = disease.state)) +
  geom_point(size = 2) +
  ylab(ylab) +
  xlab(xlab) +
  geom_text(aes(y = PC2-0.3, label = substr(sample, 7, 9)), size = 3) +
  ggtitle("Principal components")


## Hierarchichal clustering ----
# informative name:
time <- gsub(" ", "", pData$time)
time <- gsub("control", "0h", time)

disease <- gsub("nickel allergy", "AN", pData$disease.state)
disease <- gsub("non-allergic control", "C", disease)

inf_name <- paste(substr(rownames(pData), 7, 9), disease, time, sep="_" )

den_data <- exprs
colnames(den_data) <- inf_name
clust.euclid.average <- hclust(dist(t(den_data)), method = "average")
plot(clust.euclid.average, hang = -1)


# DIFFERENTIALY EXPRESSED GENS ----
## Desing ----
group <- paste(disease, time, sep="_" )
design  <-  model.matrix(~0+group)
colnames(design) <- gsub("group", "", colnames(design))
rownames(design) <- pData$sample

## Comparisons
# 1) 0h: allergic vs. control
# 2) 7h: allergic vs. control
# 3) 48h: allergic vs. control
# 4) 96h: allergic vs. control

## Contrasts ----
cont.matrix <- makeContrasts (
  time0 = AN_0h - C_0h,
  time7 = AN_7h - C_7h,
  time48 = AN_48h - C_48h,
  time96 = AN_96h - C_96h,
  levels = design)

## Fit the linear model ----
fit <- lmFit(eset_filtered, design)
fit.cont <- contrasts.fit(fit, cont.matrix)
fit.cont <- eBayes(fit.cont)

## Anotation ----
# get gene anotation
anotations <- AnnotationDbi::select(hgu133plus2.db,
                                    keys = rownames(exprs),
                                    columns = c("ENTREZID", "SYMBOL"))

# function to add annotations to result tables
anotateTable <- function(x) {
  x %>% 
    as_tibble() %>% 
    dplyr::rename("PROBEID" = "ID") %>%
    dplyr::inner_join(anotations, by = "PROBEID") %>%
    arrange(adj.P.Val)
}

## Get top tables anotated ----
topTab_time0  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time0") %>% 
  anotateTable()
topTab_time7  <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time7") %>% 
  anotateTable()
topTab_time48 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time48") %>% 
  anotateTable()
topTab_time96 <- fit.cont %>%
  topTable(number = nrow(fit.cont), coef= "time96") %>% 
  anotateTable()

# head(topTab_time0) %>% 
#  dplyr::select(PROBEID, GO.Function, adj.P.Val, ENTREZID, SYMBOL)

# Volcano plots per comparsion ----
# TIME 0
volcanoplot(fit.cont, coef = "time0", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[Time 0] nickel allergy vs. control")
abline(v = c(-1, 1))

# TIME 7
volcanoplot(fit.cont, coef = "time7", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[Time 0] nickel allergy vs. control")
abline(v = c(-1, 1))

# TIME 48
volcanoplot(fit.cont, coef = "time48", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[Time 0] nickel allergy vs. control")
abline(v = c(-1, 1))

# TIME 96
volcanoplot(fit.cont, coef = "time96", highlight = 100, 
            names = topTab_time0$SYMBOL, 
            main="[Time 0] nickel allergy vs. control")
abline(v = c(-1, 1))


## Multiple comparisons ----
summary.fit <- decideTests(fit.cont, p.value = 0.05)

# ven diagram
vc <- vennCounts(summa.fit)
vennDiagram(vc, 
            include=c("up", "down"),
            counts.col=c("red", "blue"),
            circle.col = c("red", "blue", "green3", "gold"), 
            cex=c(1, 1, 1, 1))


## Expression profile ----
topGenes0 <- subset(topTab_time0, (abs(logFC) > 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes7 <- subset(topTab_time7, (abs(logFC) > 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes48 <- subset(topTab_time48, (abs(logFC) > 0.5) & (adj.P.Val < 0.05))$SYMBOL
topGenes96 <- subset(topTab_time96, (abs(logFC) > 0.5) & (adj.P.Val < 0.05))$SYMBOL

topGenes <- unique(c(topGenes0, topGenes7, topGenes48, topGenes96))

# affy to symbol:
exprs_symb <- exprs
rownames(exprs_symb) <- anotations$SYMBOL

mat  <- exprs_symb[topGenes, ]
mat  <- mat - rowMeans(mat)
colnames(mat) <- group
pheatmap(mat)


# BIOLOGICAL SIGNIFICANCE ANALYSES ----
## Over-Representation Analysis (ORA) ----
### Time 0 ----
# no significative

### Time 7 ----
#### up ----
# no significative


### Time 48 ----
#### up ----
selectedEntrezs <- subset(topTab_time48, (logFC > 0.5) & (adj.P.Val < 0.05))$ENTREZID
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time48),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 48h; overexpressed"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# herarchical visualization of GO terms
goplot(ego, showCategory = 5, cex = 0.5)  + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)

# Enrichment map
ego_sim <- pairwise_termsim(ego)
emapplot(ego_sim, cex_label_category=0.5) + ggtitle(title)


#### down ----
selectedEntrezs <- rownames(subset(topTab_time48, (logFC < -0.5) & (adj.P.Val < 0.05)))
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time48),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 48h; regulated"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)

### Time 96 ----
#### up ----
selectedEntrezs <- rownames(subset(topTab_time96, (logFC > 0.5) & (adj.P.Val < 0.05)))
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time96),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 96h; overexpressed"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# herarchical visualization of GO terms
goplot(ego, showCategory = 5, cex = 0.5)  + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)

# Enrichment map
ego_sim <- pairwise_termsim(ego)
emapplot(ego_sim, cex_label_category=0.5) + ggtitle(title)


#### down ----
selectedEntrezs <- rownames(subset(topTab_time48, (logFC < -0.5) & (adj.P.Val < 0.05)))
ego <- enrichGO(gene = selectedEntrezs, 
                universe = rownames(topTab_time48),
                keyType = "ENTREZID",
                OrgDb = hgu133plus2.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)

title <- "Time 96h; regulated"
# dot plot of more enriched categories
dotplot(ego, showCategory = 9) + ggtitle(title)

# gene network
cnetplot(ego) + ggtitle(title)


## Gene Set Enrichment Analysis (GSEA) ----
### time 0 ----
# sort by absolute logFC to remove duplicates with smallest absolute logFC
geneList <- topTab_time0[order(abs(topTab_time0$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

set.seed(123)
gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]

### time 7 ----
# sort by absolute logFC to remove duplicates with smallest absolute logFC
geneList <- topTab_time7[order(abs(topTab_time7$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]

### time 48 ----
# sort by absolute logFC to remove duplicates with smallest absolute logFC
geneList <- topTab_time48[order(abs(topTab_time48$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest
# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]

### time 96 ----
# sort by absolute logFC to remove duplicates with smallest absolute logFC
geneList <- topTab_time96[order(abs(topTab_time96$logFC), decreasing = TRUE),]
geneList <- geneList[!duplicated(geneList$ENTREZID), ]  ### Keep highest

# re-order based on logFC to be GSEA ready
geneList <- geneList[order(geneList$logFC, decreasing = TRUE),]
genesVector <- geneList$logFC
names(genesVector) <- geneList$ENTREZID

gseResults <- gseKEGG(geneList = genesVector)

gsea.result <- setReadable(gseResults, OrgDb = hgu133plus2.db, keyType ="ENTREZID")
gsea.result.df <- as.data.frame(gsea.result)
gsea.result.df[,c("Description","setSize","NES","p.adjust")]
```

# Referències

::: {#refs}
:::

