---
title: "CDMConnector - pràctica"
subtitle: "Iniciació pràctica a l’anàlisi de dades OMOP"
author: 
  - Real World Epidemiology
institute: 
  - IDIAP Jordi Gol
format:
  html:
    embed-resources: true
editor: visual
echo: true
eval: true
toc: true
warning: false
---

## Objectiu

L'objectiu d'aquesta pràctica és connectar-se a una base de dades sintètica en format OMOP, i instanciar cohorts prèviament generades en Atlas i guardades en format .json. A més, durant aquesta activitat, es destaquen algunes particularitats de treballar amb bases de dades SQL mitjançant RStudio, i es presentaran bones pràctiques en aquest context.

## Com funciona?

En aquest fitxer trobareu un seguit d'exercicis que us proposem, acompanyats de teoria i pistes per a la seva resolució. Podeu crear un script .R en el mateix directori on hi ha aquest fitxer, i anar resolent-los en l'script. A cada exercici hi ha pistes, ja que el curs és obert a molts perfils i hi haurà gent que necessitarà indicacions sobre programació en R, altres sobre on trobar les coses a OMOP, i altres amb tot.\
A més, en aquest mateix directori, hi ha un fitxer adicional amb les solucions als exercicis, per poder auto-corregir-vos la pràctica. Si teniu qualsevol dubte pregunteu als docents de suport en les pràctiques, i intenteu utilitzar les solucions tan sols per corregir!

## Paquets R

Els paquets que utilitzarem en aquesta pràctica són els seqüents:

-   **DBI:** establir connexió amb el server (o *mock* server). \newline

-   **duckdb:** per treballar amb bases de dades SQL sintètiques.\newline

-   **CDMConnector:** per crear l'objecte cdm (conté les taules OMOP) i instànciar cohorts.

-   **dplyr:** per manipular dades.

-   **dbplyr:** per traduir les funcions del paquet dplyr a SQL i executar-les a la base de dades.

-   **here:** per obtenir la direcció del projecte on estem treballant dins del nostre ordinador.

```{r}
library(DBI)
library(duckdb)
library(CDMConnector)
library(dplyr)
library(dbplyr)
library(here)
```

## Connexió

A teoria hem vist com connectar-nos a SIDIAP-OMOP des de RStudio. Per accedir al server, s'ha d'estar connectat des d'un ordinador IDIAP Jordi Gol i s'ha de disposar d'unes credencials donades per l'equip SIDIAP. Com que no tothom disposa d' un ordinador IDIAP o bé té credencials SIDIAP-OMOP, treballarem amb una base de dades sintètica.

### Connexió SIDIAP-OMOP

A continuació mostrem el codi de connexió a SIDIAP, per si teniu l'oportunitat de connectar-vos. Per les pràctiques però, tots farem servir dades sintètiques.

```{r, echo=TRUE, eval=FALSE}
# Packages
library(DBI)
library(CDMConnector)
library(RPostgres)

# Specify database connection details 
server_dbi <- "..."
user <- "..."
password <- "..."
port <- "..."
host <- "..."

# Stablish connection
db <- DBI::dbConnect(RPostgres::Postgres(),
                     dbname   = server_dbi,
                     port     = port,
                     host     = host,
                     user     = user,
                     password = password)

# The name of the schema that contains the OMOP CDM with patient-level data
cdm_database_schema <- "..."

# The name of the schema where results tables will be created 
results_database_schema <- "..."

# create cdm object
cdm <- CDMConnector::cdm_from_con(con = db, 
                                  cdm_schema   = cdm_database_schema,
                                  write_schema = results_database_schema)

```

### Connexió Synthea

El paquet CDMConnector disposa de diverses bases de dades sintètiques, les mostrem a continuació:

```{r}
CDMConnector::exampleDatasets()
```

Per les pràctiques treballarem amb "synthea-covid19-10k". A continuació expliquem com connectar-nos:

**1. Preparar REnviron.**

En el directori "Curs_Introduccio_OMOP" d'aquest curs hi ha una subcarpeta "MockDB". En aquesta carpeta ens descarregarem la base de dades sintètica. Per fer-ho, obriu REnivron i creeu una variable "EUNOMIA_DATA_FOLDER" que contingui la direcció de la carpeta MockDB en el vostre ordinador.

::: {.callout-note appearance="simple" collapse="false"}
## Obrir REnviron

Per obrir REnvrion utilitzem `usethis::edit_r_environ()`.

A la nova pestanya que s'obrirà heu de crear la variable: EUNOMIA_DATA_FOLDER="direcció on teniu guardada la subcarpeta MockDB al vostre ordinador". Guardeu els canvis en aquesta pestanya. Per fer efectius els canvis guardats en aquest script cal reiniciar R (Session \> Restart R).
:::

**2. Connexió a Syhtea.**

El codi següent estableix connexió a la base de dades.

```{r}
db <- DBI::dbConnect(duckdb::duckdb(),
                      CDMConnector::eunomiaDir("synthea-covid19-10k"))
```

A partir d'aquí, treballem com si es tractes d'una base de dades real, per tant el que s'ha vist a teoria es pot aplicar.

### Exercici 1

##### Crear l'objecte cdm i utilitza les seves taules per respondre les següent preguntes.

La informació que us falta per crear l'objecte CDM és el nom dels schemes. En aquests cas, els dos s'anomenen "main".

Un cop tingueu l'objecte cdm, accediu a algunes de les taules per veure'n l'estructura i com es relacionen entre elles. Per exemple, la taula condition ocurrence: cada fila correspon a un diagnosi a una persona un determinat dia. El codi del diagnosi el trobem a la columna "condition_concept_id". Per saber a que fa referencia aquest diagnosi, tenim la taula "concept" on per cada "concept_id" tenim el "concept_name" que el descriu.

Recorda que per accedir a les taules s'utilitza la sintaxi `cdm$nom_taula`.

```{r, eval=TRUE, echo=FALSE, output=FALSE}
cdm <- CDMConnector::cdm_from_con(db,
                                  cdm_schema = "main",
                                  write_schema = "main")
cdm
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista

La funció que necessiteu és `cdm_from_con` del paquet CDMConnector. Podeu guiar-vos amb el codi de la secció "Connexió SIDIAP-OMOP".
:::

##### a) A que corresponen els conceptes amb codis 8532, 45756772, 21600724, and 1123810?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
cdm$concept %>%
  filter(concept_id %in% c(8532, 45756772, 21600724, 1123810)) 
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - OMOP

Els codis de l'enunciat corresponent a concept_id de la taula concept.
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Programació R

Per saber quines columnes té una taula, utilitzeu `colnames(cdm$nom_taula)`. La funció `filtre()` del paquet dplyr permet filtrar la taula segons el contingut d'una columna. Per exemple, per obteniu la persona amb person_id 10 fem

```{r}
cdm$person %>% filter(person_id == 10)
```
:::

##### b) Quantes persones registrades com a dona hi ha a la base de dades?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
cdm$person %>%
  filter(gender_concept_id == 8532) %>%
  tally()
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - OMOP

La taula "person" conté informació sobre el sexe dels pacients.
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Programació R

La funció `tally()` del paquet dplyr conta el nombre de files.
:::

##### c) Quan comença i acabava el registre de les dades?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
# inici
cdm$observation_period %>% 
  filter(observation_period_start_date == min(observation_period_start_date)) %>%
  distinct(observation_period_start_date)

# fi
cdm$observation_period %>% 
  filter(observation_period_end_date == max(observation_period_end_date)) %>%
  distinct(observation_period_end_date)
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - OMOP

La taula "observation_period" conté informació sobre quan comença (observation_period_start_date) i quan acaba (observation_period_end_date) el seguiment clínic de cada persona. Per saber quins anys estem captant amb les nostres dades, podem mirar quin és l'*start date* més petit i quin és l'*end date* més gran.
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Programació R

Per obtenir, per exemple, les files que continguin el màxim d'un valor, fem el següent:

```{r}
# taula
taula <- tibble(noms = c("Joan", "Marta", "Lluís", "Mireia"),
                puntuacio = c(2, 4, 4, 3))

# filtrem els que tenen més puntuació
taula %>%
  filter(puntuacio == max(puntuacio))
```

Per obtenir el mínim, utilitzariem la funció `min()`.
:::

## Instànciar cohorts

A continuació instanciarem les cohorts de COVID-19 creades amb Atlas i exportades en format .json. En la carpeta "Cohorts" podeu veure 3 fitxers json, 1) covid19_diagnosis, 2) covid19_diagnosis_positive_test, i 3) covid19_positive_test.

### Exercici 2

##### Instancia els .json de la carpeta "Cohorts" en una mateixa taula, i respon les preguntes

```{r, eval=TRUE, echo=FALSE, output=FALSE}
json_files <- readCohortSet(here("Cohorts")) 
json_files

table_stem <- "curs_omop_" 
table_name <- paste0(table_stem, "covid")

# Instantiate cohort to database
cdm <- generateCohortSet(cdm = cdm, 
                         cohortSet = json_files,
                         name = table_name)
cdm
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Funcions a utilitzar

Les funcions que necessiteu són `readCohortSet` i `generateCohortSet` del paquet CDMConnector. A més, la funció `here` us servirà per obtenir el directori complet de la carpeta "Cohorts".
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Pas a pas

1)  Llegir els fitxers .json amb la funció `readCohortSet`, i guardar el que retorna a una variable "json_files".

2)  Utilitzar la funció `generateCohortSet` per instanciar les cohorts. Recorda:

-   Cal introduir l'objecte cdm en el qual instanciar les cohorts (cdm), els json obtinguts en el pas 1 (cohortSet), i el nom de la taula que contindrà les cohorts (name).

-   La funció retorna l'objecte cdm amb la taula instanciada afegida. Per tant, l'output serà "cdm".
:::

##### a) Quin ID té assignat cada cohort?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
cohort_set(cdm$curs_omop_covid)
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista

Recordeu el `cohort_set`!
:::

##### b) Quantes persones hi ha en cada cohort?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
cohort_count(cdm$curs_omop_covid)
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista

Recordeu el `cohort_count`!
:::

##### c) Quants diagnostics covid hi ha hagut abans del 1 de juny del 2020? Quantes persones han estat diagnosticades amb COVID-19 abans d'aquesta data?

```{r, eval=TRUE, echo=FALSE, output=FALSE}
# nombre diagnosis
cdm$curs_omop_covid %>%
  filter(cohort_definition_id == 1) %>%
  filter(cohort_start_date > as.Date("2020-06-01")) %>%
  tally()

# nombre persones
cdm$curs_omop_covid %>%
  filter(cohort_definition_id == 1) %>%
  filter(cohort_start_date > as.Date("2020-06-01")) %>%
  distinct(subject_id) %>%
  tally()
```

::: {.callout-tip appearance="simple" collapse="true"}
## Pista

Recordeu filtrar per el cohort_definition_id d'interès!
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Programació R

Per definir una data utilitzar la funció `as.Date()`: as.Date("2020-06-01"). La funció `distinct()` elimina files duplicades, i si se li introdueix el nom d'una columna en concret, elimina els valors repetits en aquella columna.
:::

## SQL i R

**R:** És un llenguatge amigable per a l'usuari. Disposa de paquets que permeten realitzar la major part dels anàlisis estadístics que necessitem, i ofereix comandes senzilles per gestionar taules i dades (tidyverse). No obstant això, R opera completament en memòria, la qual cosa esdevé un problema quan es treballa amb bases de dades extenses com ara els registres electrònics de salut.

**SQL:** És un llenguatge de consulta de bases de dades, dissenyat específicament per emmagatzemar, gestionar i interactuar amb una base de dades. SQL és molt útil per resoldre problemes de memòria quan es treballa amb bases de dades, ja que opera al "costat de la base de dades", les dades es troben al server i no a la memòria RAM (en la qual R opera). No obstant, algunes operacions estadístiques no són possibles en SQL, o almenys són extremadament difícils i enrevessades en SQL.

El que fa el paquet dbplyr és traduir les nostres comandes R a SQL, de manera que s'executen al "costat de la base de dades" i desprès nosaltres en podem veure el resultat en RStudio. A continuació introduïm 3 funcions importants i alguns aspectes a tenir en compte.

#### compute()

[compute](https://dplyr.tidyverse.org/reference/compute.html): s'utilitza per forçar la computació d'un conjunt de comandes. Si no s'utilitza "compute", la nostra variable només conté el conjunt de comandes SQL que s'han d'executar, i no la taula resultant. És recomana utilitzar-ho al final de cada conjunt d'operacions, ja que així quan es cridi la variable en un futur, estarem cridant a la taula resultant i no a un conjunt de comandes que s'hauran d'executar cada cop.

```{r, echo=TRUE, eval=TRUE}
table7 <- cdm$person %>%
  inner_join(cdm$observation_period) %>%
  select(person_id, year_of_birth, observation_period_start_date, observation_period_end_date) %>%
  compute()
table7
```

#### collect()

[collect](https://dplyr.tidyverse.org/reference/collect.html): s'utilitza per moure un conjunt de dades des del costat de la base de dades al nostre entorn R. Típicament farem totes les operacions possibles al costat de la base de dades, i quan arribi el moment de fer algun anàlisi (per exemple, ajustar una regressió Cox), utilitzarem `collect()` per moure la taula al entorn R.

Fixa't que en la sortida següent, després d'utilitzar "`collect()`", la taula apareix com un tibble en lloc de SQL, com apareixia abans (part superior de la taula de sortida).

```{r, echo=TRUE, eval=TRUE}
table8 <- table7 %>%
  filter(year_of_birth > 2010) %>%
  collect()
table8
```

#### pull()

[pull](https://dplyr.tidyverse.org/reference/pull.html): s'utilitza per obtenir una columna d'un conjunt de dades de la taula. Per exemple, si volem un llistat de totes els person_id de la taula person.

```{r, echo=TRUE, eval=TRUE}
person_id <- cdm$person %>% pull("person_id")
person_id[1:20]
```

#### Consells d'optimització de codi:

-   Sempre és millor utilitzar les funcions de join que els filtres, per exemple: inner_join i anti_join són dues funcions molt útils.
-   Utilitza sempre compute(), collect() o pull() al final de cada línia de codi.
-   Evita canviar entre el costat de la base de dades i el costat de R si no és necessari.
-   Evita utilitzar collect() fins que necessitis tenir les dades emmagatzemades localment (per realitzar anàlisis estadístics, per exemple). En altres paraules, realitza totes les operacions possibles al costat de la base de dades.

## Exercicis extra

A continuació et proposem un conjunt d'exercicis que simulen operacions comunes que es duen a terme quan es fa l'anàlisi de dades d'un estudi. Et serviran per acabar d'entendre com funció l'estructura d'OMOP, la informació que conté cada taula, i com es relacionen entre elles.

### Exercici 3

##### Construeix una cohort de pacients COVID-19 (diagnosis) amb 180 dies d'observació prèvia a la base de dades abans de tenir COVID-19, i que tinguin entre 18 i 60 anys. Quants registres COVID-19 hi ha? Quants pacients hi ha?

```{r, echo=FALSE, eval=TRUE, output=FALSE}
# Creem la cohort
covid_db <- cdm$curs_omop_covid %>%
  filter(cohort_definition_id == 1)  %>%
  inner_join(cdm$observation_period %>%
               select(subject_id = person_id,
                      observation_period_start_date)) %>%
  filter(!!datediff("observation_period_start_date", "cohort_start_date") >= 180) %>%
  inner_join(cdm$person %>%
               select(subject_id = person_id,
                      birth_datetime)) %>%
  mutate(age = !!datediff("birth_datetime", "cohort_start_date", "year")) %>%
  filter(age >= 18 & age <= 60) %>%
  compute()

# Nombre de registres
covid_db %>% tally()

# Nombre de pacients
covid_db %>% distinct(subject_id) %>% tally()
```

::: {.callout-warning appearance="simple" collapse="false"}
## Tingues en compte

-   La columna que identifica les persones s'anomena "subject_id" en les cohorts i "person_id" en les taules del CDM.
-   Utilitza `compute()` en acabar un seguit d'operacions si treballes al server ("costat de la base de dades").
-   Les funcions de treball amb dates (e.g. les del paquet lubridate) no estan "traduïdes" d'R a SQL. Algunes, com `year()` funcionen perquè són igual en SQL, però les operacions de restar/sumar dates no. El paquet CDMConnector té la funció `datediff()` que permet fer-ho. Utilitza `?datediff` a la consola per veure com funciona.
:::

::: {.callout-tip appearance="simple" collapse="true"}
## OMOP: on trobar la informació?

La taula "observation_period" conté les dates d'inici i fi del pacient en la base de dades en les columnes "observation_period_start_date" i "observation_period_end_date", respectivament.

La taula "person" conté informació sobre la data de naixement del pacient, "birth_datetime".
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Pista - Programació R

Treballa amb la taula de la cohort que has instanciat, a la qual li pots afegir informació d'altres taules utilitzant les funcions "join". La funció `inner_join` t'ajuntarà dues taules per aquelles columnes que tinguin en comú, i només et retornarà les files que coincideixen en les dues taules. Per exemple:

```{r}
taula_1 <- tibble(noms = c("Joan", "Marta", "Lluís", "Mireia"),
                puntuacio = c(2, 4, 4, 3))
head(taula_1)

taula_2 <- tibble(noms = c("Joan", "Lluís", "Mireia", "Julia"),
                  localitat = c("Lleida", "Tarragona", "Girona", "Barcelona"))
head(taula_2)

# fem inner_join: taula resultant conte nom, puntuació i localitat dels noms que son
# comuns en les dues taules
taula_1 %>%
  inner_join(taula_2)
```
:::

### Exercici 4

##### En la cohort construida en l'exercici 3, busqueu quantes infeccions van tenir una prescripció de paracetamol durant els dies de COVID-19?

És a dir, mirar si durant la infecció COVID-19 (des de cohort_start_date a cohort_end_date), hi ha algun event de prescripció de paracetamol.

```{r, echo=FALSE, eval=TRUE, output=FALSE}
covid_paracetamol_db <- covid_db %>%
  inner_join(cdm$drug_exposure %>%
               filter(drug_concept_id == 19020053) %>%
               select(subject_id = person_id,
                      drug_exposure_start_date)) %>%
  filter(drug_exposure_start_date >= cohort_start_date & 
           drug_exposure_start_date <= cohort_end_date) %>%
  group_by(subject_id, cohort_start_date, cohort_end_date) %>%
  filter(drug_exposure_start_date == min(drug_exposure_start_date)) %>%
  ungroup() %>%
  compute()

# Nombre de registres
covid_paracetamol_db %>% tally()
```

::: {.callout-warning appearance="simple" collapse="false"}
## Tingues en compte

-   El concept_id del paracetamol és 1588667 (concept_name = acetaminophen 500 MG Oral Tablet).
-   La taula on podeu trobar aquesta informació és "drug_exposure".
-   En aquesta base de dades sintètica, pot ser hi hagi més d'una prescripció'un registre durant el temps de COVID-19, caldrà comptar-ho com una sola vegada.
-   Recorda utilitzar `compute()`, en aquesta bbdd petita no té gaire efecte en el temps computacional, però quan es treballa amb SIDIAP la diferència d'un codi que utilitza compute a un que no pot arribar a ser d'hores!
:::

::: {.callout-tip appearance="simple" collapse="true"}
## Passos

1.  Filtra la taula drug exposure per obtenir només els events d'ibuprofen.
2.  Uneix la cohort del exercici 3 amb la taula drug_exposure filtrada.
3.  Filtra la taula resultant per obtenir només les presecripcions d'ibuprofen que es van donar quan el pacient tenia COVID-19 (cohort_start_date fins cohort_end_date).
4.  Eliminar els duplicats de les prescripcions (per exemple, quedant-nos amb la primera).
:::

### Exercici 5

##### Calcula el nombre de diagnostics COVID-19 mensuals per any i intenta representar-ho en un diagrama de barres.

```{r, echo=FALSE, eval=TRUE, output=FALSE}
# instal·la lubridate si no el tens instal·lat:
# install.package("lubridate")
library(ggplot2)
library(lubridate)

covid_any <- cdm$curs_omop_covid %>%
  filter(cohort_definition_id == 1) %>%
  mutate(mes = month(cohort_start_date),
         any = year(cohort_start_date)) %>%
  group_by(mes, any) %>% 
  tally() %>%
  ungroup() %>%
  collect()

# plot
covid_any %>%
  ggplot(aes(x = mes, y = n)) +
  geom_col() +
  facet_wrap(any ~ .)
```

::: {.callout-warning appearance="simple" collapse="false"}
## Tingues en compte

-   Per extreure el mes i l'any d'una data pots utilitzar les funcions `month` i `year` del paquet lubridate. Aquest paquet es pot instal·lar amb install.packages("lubridate").
-   No podeu fer un grafic amb dades que estan al server, caldrà fer `collect()` abans.
:::
